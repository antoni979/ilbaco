-- ============================================================
-- SISTEMA DE RECOMENDACIÓN DE TALLAS - IL BACO DA SETA
-- ============================================================
-- Ejecutar este script completo en Supabase SQL Editor
-- Fecha: 2024
-- ============================================================

-- ------------------------------------------------------------
-- 1. TABLA: size_scale (Escala universal de tallas)
-- ------------------------------------------------------------
-- Mapea diferentes sistemas de tallas a una escala numérica interna
-- Esto permite hacer cálculos matemáticos entre sistemas

CREATE TABLE IF NOT EXISTS public.size_scale (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    category text NOT NULL,        -- 'tops', 'bottoms', 'shoes'
    size_system text NOT NULL,     -- 'letters', 'eu_numeric', 'us_numeric', 'uk_numeric'
    size_label text NOT NULL,      -- 'S', 'M', 'L' o '38', '40', '42'
    numeric_value decimal(4,1) NOT NULL,  -- Valor numérico interno (1-12)
    gender text DEFAULT 'unisex',  -- 'male', 'female', 'unisex'

    UNIQUE(category, size_system, size_label, gender)
);

-- Lectura pública (la app necesita consultar conversiones)
ALTER TABLE public.size_scale ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Size scale is viewable by everyone"
    ON public.size_scale FOR SELECT USING (true);

-- Insertar datos de escala: TOPS (Letras)
INSERT INTO public.size_scale (category, size_system, size_label, numeric_value, gender) VALUES
    ('tops', 'letters', 'XXS', 1, 'unisex'),
    ('tops', 'letters', 'XS', 2, 'unisex'),
    ('tops', 'letters', 'S', 3, 'unisex'),
    ('tops', 'letters', 'M', 4, 'unisex'),
    ('tops', 'letters', 'L', 5, 'unisex'),
    ('tops', 'letters', 'XL', 6, 'unisex'),
    ('tops', 'letters', 'XXL', 7, 'unisex'),
    ('tops', 'letters', 'XXXL', 8, 'unisex')
ON CONFLICT DO NOTHING;

-- Insertar datos de escala: TOPS (EU Numérico - Hombre)
INSERT INTO public.size_scale (category, size_system, size_label, numeric_value, gender) VALUES
    ('tops', 'eu_numeric', '44', 1, 'male'),
    ('tops', 'eu_numeric', '46', 2, 'male'),
    ('tops', 'eu_numeric', '48', 3, 'male'),
    ('tops', 'eu_numeric', '50', 4, 'male'),
    ('tops', 'eu_numeric', '52', 5, 'male'),
    ('tops', 'eu_numeric', '54', 6, 'male'),
    ('tops', 'eu_numeric', '56', 7, 'male'),
    ('tops', 'eu_numeric', '58', 8, 'male')
ON CONFLICT DO NOTHING;

-- Insertar datos de escala: TOPS (EU Numérico - Mujer)
INSERT INTO public.size_scale (category, size_system, size_label, numeric_value, gender) VALUES
    ('tops', 'eu_numeric', '32', 1, 'female'),
    ('tops', 'eu_numeric', '34', 2, 'female'),
    ('tops', 'eu_numeric', '36', 3, 'female'),
    ('tops', 'eu_numeric', '38', 4, 'female'),
    ('tops', 'eu_numeric', '40', 5, 'female'),
    ('tops', 'eu_numeric', '42', 6, 'female'),
    ('tops', 'eu_numeric', '44', 7, 'female'),
    ('tops', 'eu_numeric', '46', 8, 'female')
ON CONFLICT DO NOTHING;

-- Insertar datos de escala: BOTTOMS (Letras)
INSERT INTO public.size_scale (category, size_system, size_label, numeric_value, gender) VALUES
    ('bottoms', 'letters', 'XXS', 1, 'unisex'),
    ('bottoms', 'letters', 'XS', 2, 'unisex'),
    ('bottoms', 'letters', 'S', 3, 'unisex'),
    ('bottoms', 'letters', 'M', 4, 'unisex'),
    ('bottoms', 'letters', 'L', 5, 'unisex'),
    ('bottoms', 'letters', 'XL', 6, 'unisex'),
    ('bottoms', 'letters', 'XXL', 7, 'unisex'),
    ('bottoms', 'letters', 'XXXL', 8, 'unisex')
ON CONFLICT DO NOTHING;

-- Insertar datos de escala: BOTTOMS (EU Cintura - Hombre)
INSERT INTO public.size_scale (category, size_system, size_label, numeric_value, gender) VALUES
    ('bottoms', 'eu_numeric', '38', 1, 'male'),
    ('bottoms', 'eu_numeric', '40', 2, 'male'),
    ('bottoms', 'eu_numeric', '42', 3, 'male'),
    ('bottoms', 'eu_numeric', '44', 4, 'male'),
    ('bottoms', 'eu_numeric', '46', 5, 'male'),
    ('bottoms', 'eu_numeric', '48', 6, 'male'),
    ('bottoms', 'eu_numeric', '50', 7, 'male'),
    ('bottoms', 'eu_numeric', '52', 8, 'male')
ON CONFLICT DO NOTHING;

-- Insertar datos de escala: BOTTOMS (EU - Mujer)
INSERT INTO public.size_scale (category, size_system, size_label, numeric_value, gender) VALUES
    ('bottoms', 'eu_numeric', '32', 1, 'female'),
    ('bottoms', 'eu_numeric', '34', 2, 'female'),
    ('bottoms', 'eu_numeric', '36', 3, 'female'),
    ('bottoms', 'eu_numeric', '38', 4, 'female'),
    ('bottoms', 'eu_numeric', '40', 5, 'female'),
    ('bottoms', 'eu_numeric', '42', 6, 'female'),
    ('bottoms', 'eu_numeric', '44', 7, 'female'),
    ('bottoms', 'eu_numeric', '46', 8, 'female')
ON CONFLICT DO NOTHING;

-- Insertar datos de escala: SHOES (EU)
INSERT INTO public.size_scale (category, size_system, size_label, numeric_value, gender) VALUES
    ('shoes', 'eu_numeric', '36', 1, 'unisex'),
    ('shoes', 'eu_numeric', '37', 2, 'unisex'),
    ('shoes', 'eu_numeric', '38', 3, 'unisex'),
    ('shoes', 'eu_numeric', '39', 4, 'unisex'),
    ('shoes', 'eu_numeric', '40', 5, 'unisex'),
    ('shoes', 'eu_numeric', '41', 6, 'unisex'),
    ('shoes', 'eu_numeric', '42', 7, 'unisex'),
    ('shoes', 'eu_numeric', '43', 8, 'unisex'),
    ('shoes', 'eu_numeric', '44', 9, 'unisex'),
    ('shoes', 'eu_numeric', '45', 10, 'unisex'),
    ('shoes', 'eu_numeric', '46', 11, 'unisex'),
    ('shoes', 'eu_numeric', '47', 12, 'unisex')
ON CONFLICT DO NOTHING;


-- ------------------------------------------------------------
-- 2. TABLA: brand_sizing_rules (Reglas de tallaje por marca)
-- ------------------------------------------------------------
-- Define cómo talla cada marca respecto al estándar (Zara/H&M)
-- offset positivo = talla pequeño (pedir más grande)
-- offset negativo = talla grande (pedir más pequeño)

CREATE TABLE IF NOT EXISTS public.brand_sizing_rules (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    brand_name text NOT NULL,           -- Nombre de la marca (normalizado minúsculas)
    category text NOT NULL,             -- 'tops', 'bottoms', 'shoes', 'all'
    size_offset decimal(3,1) DEFAULT 0, -- Ajuste: -1.5 a +1.5
    size_system text DEFAULT 'letters', -- Sistema de tallas que usa esta marca
    fit_style text DEFAULT 'regular',   -- 'slim', 'regular', 'oversized'
    notes text,                         -- Notas adicionales

    created_at timestamp with time zone DEFAULT now(),

    UNIQUE(brand_name, category)
);

ALTER TABLE public.brand_sizing_rules ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Brand rules are viewable by everyone"
    ON public.brand_sizing_rules FOR SELECT USING (true);

-- Insertar marcas de referencia (offset 0 = estándar)
INSERT INTO public.brand_sizing_rules (brand_name, category, size_offset, fit_style, notes) VALUES
    -- Marcas estándar (referencia)
    ('zara', 'all', 0, 'regular', 'Marca de referencia estándar'),
    ('h&m', 'all', 0, 'regular', 'Marca de referencia estándar'),
    ('mango', 'all', 0, 'regular', 'Marca de referencia estándar'),

    -- Marcas que tallan pequeño (pedir una talla más)
    ('il baco', 'tops', 0.5, 'slim', 'Corte italiano, ligeramente entallado'),
    ('il baco', 'bottoms', 0, 'regular', 'Pantalones son estándar'),
    ('armani', 'all', 1, 'slim', 'Tallaje italiano pequeño'),
    ('gucci', 'all', 1, 'slim', 'Tallaje italiano pequeño'),
    ('diesel', 'bottoms', 0.5, 'slim', 'Jeans entallados'),
    ('ralph lauren', 'tops', 0.5, 'slim', 'Corte americano slim'),

    -- Marcas que tallan grande (pedir una talla menos)
    ('uniqlo', 'all', -0.5, 'regular', 'Tallaje asiático generoso para occidente'),
    ('carhartt', 'all', -1, 'oversized', 'Corte workwear amplio'),
    ('dickies', 'all', -0.5, 'oversized', 'Corte workwear'),
    ('nike', 'tops', -0.5, 'regular', 'Tallaje deportivo generoso'),
    ('adidas', 'tops', -0.5, 'regular', 'Tallaje deportivo generoso'),

    -- Marcas premium con tallaje específico
    ('levis', 'bottoms', 0, 'regular', 'Estándar en jeans'),
    ('tommy hilfiger', 'all', 0, 'regular', 'Tallaje estándar americano'),
    ('calvin klein', 'all', 0, 'slim', 'Ligeramente entallado'),
    ('boss', 'all', 0.5, 'slim', 'Corte europeo entallado'),
    ('massimo dutti', 'all', 0.5, 'slim', 'Corte europeo entallado')
ON CONFLICT (brand_name, category) DO NOTHING;


-- ------------------------------------------------------------
-- 3. TABLA: user_sizing_profile (Perfil de tallas del usuario)
-- ------------------------------------------------------------
-- Almacena las preferencias y análisis de tallas del usuario

CREATE TABLE IF NOT EXISTS public.user_sizing_profile (
    user_id uuid REFERENCES auth.users NOT NULL PRIMARY KEY,

    -- Input del usuario (Onboarding)
    height_cm int,                      -- Altura en cm (opcional pero útil)
    reference_brand text DEFAULT 'zara', -- Marca de referencia
    reference_size_top text,            -- Talla que usa en tops (ej: 'M', '40')
    reference_size_bottom text,         -- Talla que usa en bottoms
    reference_size_shoes text,          -- Talla de calzado
    preferred_fit text DEFAULT 'regular', -- 'slim', 'regular', 'loose'

    -- Medidas manuales del usuario (en cm)
    chest_cm int,                       -- Contorno de pecho
    waist_cm int,                       -- Contorno de cintura
    hip_cm int,                         -- Contorno de cadera
    shoe_size_eu text,                  -- Talla de calzado EU (ej: '43')

    -- Análisis de IA (Gemini)
    ai_body_type text,                  -- 'delgado', 'atletico', 'medio', 'robusto', 'corpulento'
    ai_shoulder_width text,             -- 'estrecho', 'medio', 'ancho'
    ai_torso_length text,               -- 'corto', 'medio', 'largo'
    ai_build_notes text,                -- Notas adicionales de la IA
    ai_fit_adjustment decimal(3,1) DEFAULT 0, -- Ajuste sugerido por IA (-1 a +1)
    ai_confidence decimal(3,2),         -- Confianza del análisis (0-1)
    ai_analyzed_at timestamp with time zone, -- Cuándo se analizó

    -- Metadata
    onboarding_completed boolean DEFAULT false,
    measurements_saved boolean DEFAULT false, -- Si ha guardado medidas manuales
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.user_sizing_profile ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own sizing profile"
    ON public.user_sizing_profile FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own sizing profile"
    ON public.user_sizing_profile FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own sizing profile"
    ON public.user_sizing_profile FOR UPDATE
    USING (auth.uid() = user_id);


-- ------------------------------------------------------------
-- 4. TABLA: purchase_history (Historial de compras)
-- ------------------------------------------------------------
-- El "rey" de las recomendaciones: si compró y no devolvió, esa es su talla

CREATE TABLE IF NOT EXISTS public.purchase_history (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users NOT NULL,

    -- Datos de la compra
    item_id bigint REFERENCES public.items,  -- Referencia al item si existe
    brand_name text NOT NULL,
    category text NOT NULL,                   -- 'tops', 'bottoms', 'shoes'
    size_purchased text NOT NULL,             -- 'M', '42', etc.

    -- Feedback post-compra
    fit_feedback int CHECK (fit_feedback BETWEEN 1 AND 5),
        -- 1: Muy pequeño
        -- 2: Algo pequeño
        -- 3: Perfecto
        -- 4: Algo grande
        -- 5: Muy grande
    returned boolean DEFAULT false,
    return_reason text,                       -- 'too_small', 'too_big', 'other'

    created_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.purchase_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own purchase history"
    ON public.purchase_history FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own purchase history"
    ON public.purchase_history FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own purchase history"
    ON public.purchase_history FOR UPDATE
    USING (auth.uid() = user_id);

-- Índice para búsquedas frecuentes
CREATE INDEX IF NOT EXISTS idx_purchase_history_user_brand
    ON public.purchase_history(user_id, brand_name, category);


-- ------------------------------------------------------------
-- 5. FUNCIÓN: get_recommended_size
-- ------------------------------------------------------------
-- Función que calcula la talla recomendada para un usuario y marca

CREATE OR REPLACE FUNCTION public.get_recommended_size(
    p_user_id uuid,
    p_brand_name text,
    p_category text,  -- 'tops', 'bottoms', 'shoes'
    p_gender text DEFAULT 'unisex'
)
RETURNS TABLE (
    recommended_size text,
    confidence text,
    reasoning text,
    alternative_size text
) AS $$
DECLARE
    v_user_profile user_sizing_profile%ROWTYPE;
    v_brand_offset decimal;
    v_brand_system text;
    v_reference_size text;
    v_base_numeric decimal;
    v_adjusted_numeric decimal;
    v_ai_adjustment decimal;
    v_history_adjustment decimal;
    v_final_numeric decimal;
    v_reasoning_parts text[];
BEGIN
    -- 1. Obtener perfil del usuario
    SELECT * INTO v_user_profile
    FROM user_sizing_profile
    WHERE user_id = p_user_id;

    IF v_user_profile IS NULL THEN
        RETURN QUERY SELECT
            'M'::text,
            'low'::text,
            'No hay perfil de tallas configurado'::text,
            'L'::text;
        RETURN;
    END IF;

    -- 2. Obtener talla de referencia según categoría
    v_reference_size := CASE p_category
        WHEN 'tops' THEN v_user_profile.reference_size_top
        WHEN 'bottoms' THEN v_user_profile.reference_size_bottom
        WHEN 'shoes' THEN v_user_profile.reference_size_shoes
        ELSE v_user_profile.reference_size_top
    END;

    IF v_reference_size IS NULL THEN
        RETURN QUERY SELECT
            'M'::text,
            'low'::text,
            'No hay talla de referencia para esta categoría'::text,
            'L'::text;
        RETURN;
    END IF;

    -- 3. Convertir talla de referencia a valor numérico
    SELECT numeric_value INTO v_base_numeric
    FROM size_scale
    WHERE category = p_category
      AND size_label = UPPER(v_reference_size)
      AND (gender = p_gender OR gender = 'unisex')
    LIMIT 1;

    IF v_base_numeric IS NULL THEN
        -- Intentar como número directo
        v_base_numeric := 4; -- Default a M
    END IF;

    v_reasoning_parts := ARRAY['Base: ' || v_reference_size || ' (valor ' || v_base_numeric || ')'];

    -- 4. Obtener offset de la marca
    SELECT size_offset, size_system INTO v_brand_offset, v_brand_system
    FROM brand_sizing_rules
    WHERE brand_name = LOWER(p_brand_name)
      AND (category = p_category OR category = 'all')
    ORDER BY CASE WHEN category = p_category THEN 0 ELSE 1 END
    LIMIT 1;

    v_brand_offset := COALESCE(v_brand_offset, 0);
    v_brand_system := COALESCE(v_brand_system, 'letters');

    IF v_brand_offset != 0 THEN
        v_reasoning_parts := array_append(v_reasoning_parts,
            'Marca ' || p_brand_name || ': ' ||
            CASE WHEN v_brand_offset > 0 THEN '+' ELSE '' END ||
            v_brand_offset::text);
    END IF;

    -- 5. Aplicar ajuste de IA
    v_ai_adjustment := COALESCE(v_user_profile.ai_fit_adjustment, 0);

    IF v_ai_adjustment != 0 THEN
        v_reasoning_parts := array_append(v_reasoning_parts,
            'Ajuste IA: ' ||
            CASE WHEN v_ai_adjustment > 0 THEN '+' ELSE '' END ||
            v_ai_adjustment::text);
    END IF;

    -- 6. Verificar historial de compras (tiene prioridad)
    SELECT
        CASE
            WHEN fit_feedback = 3 AND NOT returned THEN 0  -- Perfecto
            WHEN fit_feedback < 3 OR return_reason = 'too_small' THEN 1  -- Muy pequeño -> subir
            WHEN fit_feedback > 3 OR return_reason = 'too_big' THEN -1  -- Muy grande -> bajar
            ELSE 0
        END INTO v_history_adjustment
    FROM purchase_history
    WHERE user_id = p_user_id
      AND LOWER(brand_name) = LOWER(p_brand_name)
      AND category = p_category
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_history_adjustment IS NOT NULL AND v_history_adjustment != 0 THEN
        v_reasoning_parts := array_append(v_reasoning_parts,
            'Historial: ' ||
            CASE WHEN v_history_adjustment > 0 THEN '+' ELSE '' END ||
            v_history_adjustment::text);
    END IF;

    v_history_adjustment := COALESCE(v_history_adjustment, 0);

    -- 7. Calcular talla final
    v_final_numeric := v_base_numeric + v_brand_offset + v_ai_adjustment + v_history_adjustment;

    -- Limitar a rango válido
    v_final_numeric := GREATEST(1, LEAST(8, v_final_numeric));

    -- 8. Convertir de vuelta a etiqueta de talla
    RETURN QUERY
    SELECT
        ss.size_label,
        CASE
            WHEN v_user_profile.ai_confidence >= 0.8 AND v_history_adjustment = 0 THEN 'high'
            WHEN v_user_profile.ai_confidence >= 0.5 OR v_history_adjustment != 0 THEN 'medium'
            ELSE 'low'
        END::text,
        array_to_string(v_reasoning_parts, ' | ')::text,
        ss_alt.size_label
    FROM size_scale ss
    LEFT JOIN size_scale ss_alt ON ss_alt.category = p_category
        AND ss_alt.size_system = v_brand_system
        AND ss_alt.numeric_value = LEAST(8, ROUND(v_final_numeric) + 1)
        AND (ss_alt.gender = p_gender OR ss_alt.gender = 'unisex')
    WHERE ss.category = p_category
      AND ss.size_system = v_brand_system
      AND ss.numeric_value = ROUND(v_final_numeric)
      AND (ss.gender = p_gender OR ss.gender = 'unisex')
    LIMIT 1;

    -- Si no encontró, devolver default
    IF NOT FOUND THEN
        RETURN QUERY SELECT
            'M'::text,
            'low'::text,
            array_to_string(v_reasoning_parts, ' | ')::text,
            'L'::text;
    END IF;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Dar permisos de ejecución
GRANT EXECUTE ON FUNCTION public.get_recommended_size TO authenticated;


-- ------------------------------------------------------------
-- 6. FUNCIÓN: Trigger para actualizar updated_at
-- ------------------------------------------------------------

CREATE OR REPLACE FUNCTION public.update_sizing_profile_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_user_sizing_profile_timestamp
    BEFORE UPDATE ON public.user_sizing_profile
    FOR EACH ROW
    EXECUTE FUNCTION public.update_sizing_profile_timestamp();


-- ============================================================
-- FIN DEL SCRIPT
-- ============================================================
-- Para verificar que todo se creó correctamente, ejecuta:
-- SELECT * FROM size_scale LIMIT 10;
-- SELECT * FROM brand_sizing_rules LIMIT 10;
-- ============================================================
